= Scatter Payload Elements into Different Parallel Processes, then Gather the Results
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

:imagesdir: ../assets/images

== Example: Aggregating Contacts from Two Salesforce Organizations


image::fd-sg-1-entire-flow.png[]
<1> An HTTP Listener card for triggering the flow.
<2> An Scatter-Gather card with two routes configured, each route consisting of an instance of Salesforce Connector. The instances query different Salesforce organizations.
<3> A Set Variable card for storing the payload from the Scatter-Gather card in a variable.
<4> A Transform card for mapping the fields in the variable to the fields in a CSV file.

The HTTP Listener card is uses the default CloudHub HTTP configuration. The only change made to it is that a value is specified in the *Path* field.

image::fd-sg-2-http-listener.png[]

The instances of Salesforce Connector use different configurations because they require different connections. The same query is in the *Salesforce Query* field in each instance.

image::fd-sg-3-sf-query.png[]

The Set Variable card includes 1) a name for the variable and 2) an expression in the *Value* field. The expression is this:

----
payload["0"]["payload"] ++ (payload["1"]["payload"])
----

You can create this expression by dragging the *Custom Expression* pill from the right side of the card into the *Value* field, clicking the arrow in the pill, and clicking *Expand*. Then, drag the first *Payload* pill into the text box, add the two plus signs, then drag the second *Payload* pill into the text field.

image::fd-sg-4-set-variable.png[]

In the Transform card, the fields that were saved into the `SG_payload` variable are mapped to the fields of a custom data type.

image::fd-sg-5-transform.png[]

The custom data type is of the CSV format and looks like this:

----
#%RAML 1.0 DataType
type: array
items:
  properties:
    Name:
      type: string
    ID:
      type: string
    Email:
      type: string
----

image::fd-sg-6-custom-type.png[]


== Differences between Parallel For-Each, For-Each, and Scatter-Gather

For-Each iterates through a collection of elements, processing one element at a time through a single route.

Parallel For-Each iterates though a collection of elements _n_ times (where _n_ <= the number of elements in the collection) with a single process. For example, if there are 10 elements and the maximum number of processes is set to 2, a Parallel For-Each component processes two elements at a time, five times.

Scatter Gather runs two or more parallel processes, called _routes_. Each route differs from the other routes. Scatter Gather sets conditions that determine which route processes a particular part of a payload. When all routes are finished, the results from each route are gathered together into a new payload.

Timeout:: The maximum length of time to wait, in milliseconds, for the results from each of the parallel processes to be gathered together into a new payload and sent to the next card. A value of 0 or lower means that there is no timeout. The default value is 9,223,372,036,854,776,000 milliseconds.

Max concurrency:: The maximum number of routes to process in parallel. By default, all of the routes that you create in for an instance of the Scatter-Gather component run in parallel. If you do not set a value, the value used is the number of routes.
+
If you set this value to 1, Scatter Gather takes the first element in the payload, evaluates it against the condition set up for each route, and sends the element through the route for which it meets the condition. When a route is done processing an element, Scatter Gather evaluates the next element against the routing conditions, continuing until the elements in the payload have all been processed.
