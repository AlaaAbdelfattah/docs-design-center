= Processing Elements in Collections
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

:imagesdir: ../assets/images

You can process elements in a collection by using the For-Each component or the Parallel For-Each component. Each component sets a scope within which you can add other types of component, as well as connectors and modules, for processing each element.

.The For-Each component and the Parallel For-Each component both set scopes for processing the elements within a collection.
image::fd-iterators-example.png[Two simple examples: one of the use of For-Each, the other of the use of Parallel For-Each]

<1> The For-Each component in this example inserts each element, one at a time, into a database. Each element is presumably a string that can be used in a SQL INSERT statement.
<2> The Parallel For-Each component in this example sends each element to a Set Payload component that modifies the element with an expression and adds it to the flow's payload.

Both types of component can process any collection, including lists and arrays. A collection can be any supported content type, such as application/json, application/java, or application/xml. For an XML or JSON collection, specify a DataWeave expression in the *Collection* field to split the collection into its constituent elements. The For-Each or Parallel For-Each scope can split a Java collection into its elements without depending on a DataWeave expression to explain how to split it.

== How the For-Each Component Processes Data and Continues a Flow

The For-Each component is for processing each element in a collection serially and then proceeding in the flow with the original payload that was passed to the For-Each component:

image::fd-foreach.png[Diagram depicting the actions taken by the For-Each component]

<1> A card passes the payload of a flow to the For-Each component.
<2> The For-Each component sends each element serially to the components, connectors, and modules that are in its scope. Each element is treated as a payload within the scope. So, if a connector within the scope is configured to act on `payload` or uses a script to process `payload`, the payload is not the payload that the For-Each component received.
<3> After the final element is processed, the For-Each component passes the payload that it received from the previous card to the next card in the flow.
<4> The next card in the flow receives the same payload that the For-Each component received, and the flow continues.

== How the Parallel For-Each Component Processes Data and Continues a Flow

The Parallel For-Each component is for processing each element in a collection and then passing the results to the next card in the flow:

image::fd-parallel-foreach.png[Diagram depicting the actions taken by the Parallel For-Each component]

<1> A card passes the payload of a flow to the Parallel For-Each component.
<2> The Parallel For-Each component sends elements simultaneously to the components, connectors, and modules that are in its scope. You can specify the maximum number of elements to process at a time. Each element is treated as a payload within the scope. So, if a connector within the scope is configured to act on `payload` or uses a script to process `payload`, the payload is not the payload that the Parallel For-Each component received.
<3> After all of the elements are processed, the Parallel For-Each component aggregates and passes the results of the processing that was done within its scope. The results form the payload that is passed to the next card in the flow.
<4> The next card in the flow receives the results from the Parallel For-Each component, and the flow continues.

The order of the results correspond to the order of the elements in the original payload. For example, suppose that the payload that is passed to a Parallel For-Each component is `["Apple","Banana","Cherry"]`. Within the component's scope is a Set Payload component that processes each element as a separate payload. The Set Payload component processes each payload with this DataWeave expression: `payload ++ '-result'`. The Parallel For-Each component passes these results to the next card in the flow: `["Apple-result","Banana-result","Cherry-result"]`.

[IMPORTANT]
====
Within the scope of the Parallel For-Each component, the order in which each element is processed is not guaranteed to be the order in which each element appears in a collection. Therefore, if any of the connectors require elements in a particular order (for example, if you want to update database tables in a particular order with the Database connector), you should use the For-Each component instead.

Moreover, you should be aware whether any APIs or services that you want to connect to within the scope of a Parallel For-Each component have any limits in the number of concurrent connections that they accept. If they do, you must specify a maximum number of concurrent processes for the Parallel For-Each component.
====


== Transactional Processing

The For-Each component does nothing differently when running within a transaction. // What does it mean "to run within a transation"? I know what a transaction is, but how does a component run "within" one?

However, the Parallel For-Each component does not process the elements of a collection simultaneously. Instead, it processes them serially, just as the For-Each component does. The output from this component is still the aggregated results from the processing of the elements in a collection.

== Batching

With the For-Each component, you can split a collection into batches to enable quicker processing. Each batch is treated as a separate Mule message. For example, if a collection has 200 elements and you set Batch Size to 50, the For-Each component iteratively processes 4 batches of 50 elements, each as a separate Mule message.

Batching is not supported with the Parallel For-Each component.

== Variable Propagation
        For-Each
          Every execution of the For Each scope starts with the variables and values from the previous execution of the block. New variables or modifications to existing variables that take place when processing one element are visible during the processing of another element. These changes to variables continue to be available outside the For Each scope.
        Parallel For-Each
          Every execution of the Parallel For Each scope starts with the same variables and values as before the execution of the block.
            I asked Cristian questions about this sentence.
          New variables or modifications of already existing variables while processing one element are not visible while processing another element. All of those variable changes are not available outside the Parallel For Each scope, the set of variables (and their values) after the execution of the Parallel For Each Scope remains the same as before the execution.
          None of the modifications done inside the Parallel For-Each scope are registered, including the creation of new variables.
            I asked Cristian questions about this sentence.

== Error Handling
        For-Each
          If one of the elements in a collection throws an exception, the For Each scope stops processing that collection. Flow Designer shows a red circle on the For-Each card. Look in the log to find out the reason for the failure.
        Parallel For-Each
          When one of the parallel executions timeouts, an exception is raised, stopping the flow.
          Flow designer will show a red icon in the top left part of the card as it does with all the errors in the cards. The user can take a look at the logs to check why it failed.

== Configuring For-Each

Collection:: An expression that returns a Java collection, object array, map, or DOM nodes.

Batch Size:: Partitions the collection into sub-collections of the specified size. For example, if a collection has 200 elements and you set the batch size to 50, it processes 4 batches of 50 elements each.

Root Message Variable Name:: Name of the property that stores the parent message. The parent is the complete, non-split message.

Counter Variable Name:: Name of the property that stores the number of messages over which it iterates. // What is "it"?


== Configuring Parallel For-Each

Collection:: Specifies the expression that defines the collection of parts to be processed in parallel. By default, it uses the incoming payload.

Timeout:: Specifies the timeout for each parallel route.

Max Concurrency:: Specifies the maximum level of parallelism to use. By default, all routes run in parallel.


Advanced

Target:: Specifies a variable to use for storing the processed payload. By default, the output is saved in the flow’s payload.

Target Value:: Specifies an expression to evaluate against the operation’s output value. The outcome of this expression is stored in the target variable. By default, this is the same as the operation’s output value.
