= Mapping the Output of a Card to the Expected Input of the Next Card
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

:imagesdir: ../assets/images

A card in a flow might require that the data that is sent to it be in a certain format or contain certain elements. In such a situation, that card expects a particular data type. You might have to map the output of the preceding card to that data type.

For example, suppose that a card contains Card A and Card B, and that Card B follows Card A. If the output of Card A uses the same data type that Card B requires for its input, then you do not have to map the output of Card A to the input of Card B. However, if the two data types do not match, you have to map data from the output of Card A to the data type required by Card B.

== Example from the tutorial
If you followed the steps in the tutorial "xref::salesforce-to-twilio.adoc[Create Your First Mule Application with Flow Designer]", then you have already performed such a mapping twice. The first time, you needed to map the output of the Choice card to the input that was required by the NTO Order API.

.Data types output by the Choice card and the data type required by the NTO Order API
[cols="1a,1a"]
|====
| Data types output by the Choice card | Data type required as input by the NTO Order API

|
.The Product Information data type
----
[
  {
    "productID": string,
    "category": string,
    "SKU": string,
    "productName": string,
    "inventory": string
  }
]
----

.The Salesforce Opportunity data type
----
{
  "Amount": number,
  "Id": string,
  "CloseDate": string,
  "Name": string
}
----
|
.The Order Information data type
----
{
  "OppId": string,
  "OrderAmount": number,
  "orderdate": string,
  "productInfo": {
     "productID": string,
     "category": string,
     "SKU": string,
     "productName": string,
     "inventory": number
     }
}
----
|====

To do the mapping, you used a Transform card, clicking and dragging elements from the *Input* side to elements on the *Output* side. (In the Transform card, "input" and "output" are terms that are relative to the Transform card itself. The "input" to the Transform card was the output of the Choice card, and the "output" of the Transform card was the input to the Order API.)

.The Transform card that mapped the output of the Choice card to the input required by the API
image::transform-first-final.png[]

You had to do the mapping because the Order API (which was a REST API that you sent a POST message to) did not require all of the data that was in the output of the Choice card. Moreover, some of the elements of the data required by the API had names that differed from the corresponding elements in the Choice card's output

.The requirement for mapping data from the Choice card to data for the Order API
[%header,cols=2*]
|===
|This Element from the Choice card
|Mapped to This Element for the Order API

|`productID`
|`productID`

|`category`
|`category`

|`SKU`
|`SKU`

|`productName`
|`productName`

|`inventory`
|`inventory`

|`Amount`
|`OrderAmount`

|`Id`
|`OppId`

|`CloseDate`
|`orderDate`

|===

The second time you mapped in the tutorial, you did not need to set a data type explicitly for the input of the Twilio card. The Transform card was able to determine the data structure that the Twilio card required. Also, you did not map data elements. Rather, in the output of the Transform card, you used a DataWeave script to pull data from the input of the Transform card into a message to send customers.

.The DataWeave script that used data from the input to the Transformation card
image::transform-second-script-panel.png[]
