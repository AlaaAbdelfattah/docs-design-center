= Data Types (Flow Designer)
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

:imagesdir: ../assets/images

A _data type_ explains to Flow Designer the format and structure of the data that is received by a card and that a card produces as output.

[%header,cols=4*]
|===
|Format
|Has a structure?
|Requires an example?
|Requires a schema?

|CSV
|Yes
|No
|Yes, as a RAML definition

|JSON
|Yes
|Yes, if you don't provide a schema.
|Yes, if you don't provide an example.

|Object
|Yes
|No
|Yes, as a RAML definition

|XML
|Yes
|Yes, if you don't provide a schema.
|Yes, if you don't provide an example.

|Boolean
|No
|No
|No

|Date
|No
|No
|No

|DateTime
|No
|No
|No

|Integer
|No
|No
|No

|Number
|No
|No
|No

|String
|No
|No
|No



|===

When you build a flow, you must be aware of the format and structure, or _data type_, of the data that each card requires as input, and that each card produces as output. The data type of the output of a card might not match the data type of the input that the next card requires. To overcome the problem, you would need to map elements in the data types by using a Transform card.

For example, Figure 1 depicts a simple flow in which each card receives as input data that is in exactly the same data type as the data that the previous card produces as output.

.A simple flow for thinking about data types
image::fd-inputs-outputs-easy.png[]

. A process outside of the application triggers the flow by sending data that is in a certain data type.
. Card 1 receives that data and produces its output.
. Card 2 happens to require data in the same data type, so it is able to receive Card 1's output as input. Card 2 produces an output that is in a different data type.
. Fortunately, the next card in the flow can receive that output as its input.

For this flow, you would need to be aware of the data type that is output by Card 1, the required data type for input to Card 2, the data type output by Card 2, and the required data type for the next card. Because each output of a card can be used _as is_ for the input of the next card, you do not have to transform any of the outputs into required inputs.

Figure 2 depicts a flow that requires at least one transformation.

.A slightly less simple flow for thinking about data types
image::fd-inputs-outpus-harder.png[]

. As in Figure 1, a process outside of the application triggers the flow by sending data that is in a certain data type.
. Again, Card 1 receives that data and produces its output.
. However, Card 2 requires its input to use a different data type. Therefore, you must place a Transform card between Card 1 and Card 2. In the Transform card, you must map elements from Card 1's output data type to elements in Card 2's required input data type.

Not all data types need to




In the early stage of development, you define data types to answer these questions. You include an example or schema of the expected data that the app uses. Some formats require a schema. Provide a schema for a CSV or Java format in a RAML file.

Defining data types helps you design the application in the following ways:

* Provides auto-completion hints when writing expressions
* Generates DataWeave code and a preview of transformation results when you map real or example input to output
* Reveals metadata for troubleshooting problems

Some designs, such as those using Salesforce, require no data type definitions. Salesforce objects have a well-defined structure that Design Center can easily reference.

When you run the app, the flow starts executing when triggered. Real data appears in lieu of example data in the input and output. You can inspect payload, attributes, and vars (variables) at various stages of the flow.




== Using RAML to Define Data

The HTTP Request Connector does not expose any information by default, but you can configure the connector using a RAML API specification, which includes information about required inputs and expected outputs.

== See Also

* xref:flow-datatype-task.adoc[To Set Data Types for a Flow]
