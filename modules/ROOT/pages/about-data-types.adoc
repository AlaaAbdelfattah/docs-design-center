= Data Types (Flow Designer)
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

:imagesdir: ../assets/images

A _data type_ explains to Flow Designer the format and structure of the data that is received by a card and that a card produces as output.


== Why you need to know the data types used in your flows

When you build a flow, you must be aware of the data types that each card requires as input, and that each card produces as output. The data type of the output of a card might not match the data type of the input that the next card requires. To overcome the problem, you would need to map elements in the data types by using a Transform card.

For example, Figure 1 depicts a simple flow in which each card receives as input data that is in exactly the same data type as the data that the previous card produces as output.

.A simple flow for thinking about data types
image::fd-inputs-outputs-easy.png[]

. A process outside of the application triggers the flow by sending data that is in a certain data type.
. Card 1 receives that data and produces its output.
. Card 2 happens to require data in the same data type, so it is able to receive Card 1's output as input. Card 2 produces an output that is in a different data type.
. Fortunately, the next card in the flow can receive that output as its input.

For this flow, you would need to be aware of the data type that is output by Card 1, the required data type for input to Card 2, the data type output by Card 2, and the required data type for the next card. Because each output of a card can be used _as is_ for the input of the next card, you do not have to transform any of the outputs into required inputs.

Figure 2 depicts a flow that requires at least one transformation.

.A slightly less simple flow for thinking about data types
image::fd-inputs-outpus-harder.png[]

. As in Figure 1, a process outside of the application triggers the flow by sending data that is in a certain data type.
. Again, Card 1 receives that data and produces its output.
. However, Card 2 requires its input to use a different data type. Therefore, you must place a Transform card between Card 1 and Card 2. In the Transform card, you must map elements from Card 1's output data type to elements in Card 2's required input data type.


== Data types that are supported in flows

There are two categories of data type:

=== Simple data types
These data types are boolean, date, dateTime, integer, number, and string.

Boolean:: Evaluates to true or false. Possible values: `true`, `false`

Date:: Stores a year, month, and day as `yyyy-MM-dd`.

DateTime:: Stores a date and time within a time zone, where a time zone is the time relative to Greenwich Mean Time (GMT). A time zone must include a + or a -. For example, `03:00:00` is a time, while `+03:00` is a time zone. Example that represents 12:30 p.m. on June 1, 2019 in Macau: `2019-06-01T12:30:00+08:00`

Integer:: Stores whole numbers that range from -2,147,483,647 to 2,147,483,647. An integer has no decimal point.

Number:: A `number` stores a float number, which can range from 1.40129846432481707e-45 to 3.40282346638528860e+38 and include a decimal point, or an integer.

String:: Stores text, numbers (not `number` data types), or a combination of both. Examples: "94u0sfjlk*(f!`lkkjd", "18005555555", "Fred"

=== Structured data types

CSV:: Data can enter a card as comma-separated values. This data format is frequently used for exporting the content of spreadsheets. When you use this data type in Flow Designer, you must provide a schema in REST API Modeling Language (RAML) that explains to Flow Designer how to read the data. Here is an example of a simple schema:
+
----
#%RAML 1.0 DataType
type: array
items:
    properties:
        firstname:
            type: string
        lastname:
            type: string
        age:
            type: number
----

JSON:: JavaScript Object Notatation (JSON) is a format that structures data in key/value pairs. When you use this data type, you must provide either an example that contains sample data or the JSON schema on which the data type is based.
+
.Example JSON schema
----
{
  "$id": "https://example.com/person.schema.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Person",
  "type": "object",
  "properties": {
    "firstName": {
      "type": "string",
      "description": "The person's first name."
    },
    "lastName": {
      "type": "string",
      "description": "The person's last name."
    },
    "age": {
      "description": "Age in years which must be equal to or greater than zero.",
      "type": "integer",
      "minimum": 0
    }
  }
}
----
+
.Corresponding example JSON file
----
{
  "firstName": "Olafur",
  "lastName": "Karlsson",
  "age": "45"
}
----

Object:: This data type is a Java object. When you use this data type in Flow Designer, you must provide a schema in REST API Modeling Language (RAML) that explains to Flow Designer how to read the data. Here is an example of a simple schema:
+
----
#%RAML 1.0 DataType
type: object
properties:
    field1:
        type: string
    field2:
        properties:
            field21:
                type: string
            field22:
                type: string
----

XML::

s
=== Table of data types

[%header,cols=4*]
|===
|Format
|Category
|Requires an example?
|Requires a schema?

|Boolean
|Simple
|No
|No

|Date
|Simple
|No
|No

|DateTime
|Simple
|No
|No

|Integer
|Simple
|No
|No

|Number
|Simple
|No
|No

|String
|Simple
|No
|No
|CSV
|Structured
|No
|Yes, as a RAML definition

|JSON
|Structured
|Yes, if you don't provide a schema.
|Yes, if you don't provide an example.

|Object
|Structured
|No
|Yes, as a RAML definition

|XML
|Structured
|Yes, if you don't provide a schema.
|Yes, if you don't provide an example.

|===


Not all data types need to




CSV:: Example of a RAML schema:
+
----
#%RAML 1.0 DataType
type: array
items:
    properties:
        firstname:
            type: string
        lastname:
            type: string
        age:
            type: number
----

Object:: Example of a RAML schema:
+
----
#%RAML 1.0 DataType
type: object
properties:
    field1:
        type: string
    field2:
        properties:
            field21:
                type: string
            field22:
                type: string
----

When you run the app, the flow starts executing when triggered. Real data appears in lieu of example data in the input and output. You can inspect payload, attributes, and vars (variables) at various stages of the flow.



== See Also

* xref:flow-datatype-task.adoc[To Set Data Types for a Flow]
